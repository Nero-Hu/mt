#!/usr/bin/env python
import sys
import optparse
import models
from collections import namedtuple

class GreedyDecode:
	"""Greedy Decoder"""
	def __init__(self, opts):
		self.tm = models.TM(opts.tm, opts.k)
		self.lm = models.LM(opts.lm)
		self.french = [tuple(line.strip().split()) for line in open(opts.input).readlines()[:1]]
		self.alpha = opts.alpha
		self.distantThreshold = 3
		self.translationPair = namedtuple("translationPair", \
			"logprob, lm_state, predecessor, phrase, srcStartPos, srcEndPos, srcWordCounts, srcPhraseCounts, tgtEndPos")

		# tm should translate unknown words as-is with probability 1
		for word in set(sum(self.french,())):
			if (word,) not in self.tm:
				self.tm[(word,)] = [models.phrase(word, 0.0)]

		sys.stderr.write("Decoding %s...\n" % (opts.input,))

	def train(self):
		# Implement greedy decoding, above shameless copy
		for f in self.french:
			#hillClimb(f)
			self.seed(f)


	# Initialize the translation
	def seed(self, f):
		"""
		Choose an initial segmentation
		"""
		translationPairList = self.stackDecode(f)
		for pair in translationPairList:
			

	# Use stack decode to get maximum phrase translation
	def stackDecode(self, f):
		"""
		Below comes from sample stack decoding program, but the tuple has been modified
		to record more location information
		"""
		translationPairList = []
		initial_translationPair = self.translationPair(0.0, self.lm.begin(), None, None, 0, 0, 0, 0, 0)
		stacks = [{} for _ in f] + [{}]
		stacks[0][self.lm.begin()] = initial_translationPair
		for i, stack in enumerate(stacks[:-1]):
			for h in sorted(stack.itervalues(),key=lambda h: -h.logprob)[:1]: # prune
				for j in xrange(i+1,len(f)+1):
					if f[i:j] in self.tm:
						for phrase in self.tm[f[i:j]]:
							logprob = h.logprob + phrase.logprob
							phrase_count = h.srcPhraseCounts + 1
							lm_state = h.lm_state
							tgtEndPos = h.tgtEndPos
							for word in phrase.english.split():
								tgtEndPos += 1
								(lm_state, word_logprob) = self.lm.score(lm_state, word)
								logprob += word_logprob

							logprob += self.lm.end(lm_state) if j == len(f) else 0.0
							new_translationPair = self.translationPair(logprob, lm_state, h, phrase,i, j, i, phrase_count, tgtEndPos)
							if lm_state not in stacks[j] or stacks[j][lm_state].logprob < logprob: # second case is recombination
								stacks[j][lm_state] = new_translationPair

		winner = max(stacks[-1].itervalues(), key=lambda h: h.logprob)
		def extract_english(h): 
			if h.predecessor is not None:
				extract_english(h.predecessor)
			translationPairList.append(h)
			return

		extract_english(winner)
		# for pair in translationPairList:
		# 	print pair.logprob, pair.phrase, pair.srcStartPos, pair.srcEndPos, pair.srcWordCounts, pair.srcPhraseCounts, pair.tgtEndPos
		return translationPairList

	def max(t1, t2):
		if (t2.c > t1.c) or (t2.c == t1.c and t1.n > t2.n):
			return t2
		return t1


	# Score a current translation
	def score(self, current):
		"""
		Current should be a list of current translation,
		"""
		for pair in current:
			print pair


	def distortionProb(i,j):
		"""
		i is the start position of foreigh language
		j is the end position of English phrase
		"""
		return alpha**abs(i-j-1)

	def hillClimb(self, source):
		current = seed(source)
		while True:
			s_current = score(current)
			s = s_current
			best = current
			for h in neighborhood(current):
				c = score(h)
				if c > s:
					s = c
					best = h
			if s == s_current:
				return current
			else:
				current = best

def main(argv):
	optparser = optparse.OptionParser()
	optparser.add_option("-i", "--input", dest="input", default="data/input", help="File containing sentences to translate (default=data/input)")
	optparser.add_option("-t", "--translation-model", dest="tm", default="data/tm", help="File containing translation model (default=data/tm)")
	optparser.add_option("-l", "--language-model", dest="lm", default="data/lm", help="File containing ARPA-format language model (default=data/lm)")
	optparser.add_option("-n", "--num_sentences", dest="num_sents", default=sys.maxint, type="int", help="Number of sentences to decode (default=no limit)")
	optparser.add_option("-k", "--translations-per-phrase", dest="k", default=1, type="int", help="Limit on number of translations to consider per phrase (default=1)")
	optparser.add_option("-s", "--stack-size", dest="alpha", default=0.05, type="float", help="Distortion Constant (default=0.05)")
	opts = optparser.parse_args()[0]

	gd = GreedyDecode(opts)
	gd.train()

if __name__=='__main__':
	main(sys.argv)
